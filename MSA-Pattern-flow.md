# MSA (MicroService Architecture)

1. 시작은 Monolithic 아키텍쳐 - 기본 하나의 서버 하나의 DB에.
- 배포시 전체를 다 스케일링 해줘야해서 개발사이클이 늦어짐.
2. 배포단위를 나누자 - 서버를 도메인 기준으로 분리함. MSA의 시작.
3. 서버가 모두 같은 DB를 바라보면서 동기화문제가 생김.
4. 각 서비스별로 독립적인 DB를 둠. - 현재 가장 많이쓰는 형태.
5. 서비스별로 통신을 더욱 자주, 많이 하게됨. HTTP로 통신하기에는 난이도가 높아짐.
6. 더 로우레벨에서 통신할수있는 gRPC(Remote Procedure Call)같은 걸 사용하게됨. 속도의강점.
7. 서비스에서 워터폴 이펙트가 생김. Synchronous(동기화) 문제. ex a().b().c() 에서 a가 끝나지않으면 결국 b,c전부 대기중
8. Asynchronous(비동기) 방식으로 하기위해 이벤트드리븐아키텍쳐가 생김.
  - 요청을 EventBroker에 이벤트에 등록하고 끝냄.
  - 특정이벤트를 구독하고있는 다른 서비스가 이벤트를 가져가서 처리함.
9. 그러나 Process가 필요한 서비스들이있음. 여러 마이크로서비스서버에 거쳐서 다중작업을 하게되는데, 그중에 에러가 나면 분산된 DB 때문에 롤백이 어려움.
10. Saga Pattern이 나옴.
  - 여러 서비스의 트랜잭션을 묶어주고, 문제가 나면 보상트랜젝션을 통해 롤백을 함.
  - 중개서버가 하나 필요함. 떄문에 이벤트드리븐 아키텍쳐와 같이 쓰면좋음.
11. 기존 Monologo 에서는 CRUD 로 개발을 하엿는데, MSA에서는 각 MS의 주목적이나 특징이 생김. 
    그 특징을 기준으로 MS를 command와 Query부분을 분리함. 그러면서 각각 MS별로 생성이나 조회에 최적화 DB를 사용하게됨. 효율을 높임.<br>
    독립적인 스케일링이 가능해져서 인프라 최적화도 더욱 타이트해짐.<br>
    *이것이 CQRS(Command Query Responsibiliy Segregration) 패턴*
    커맨드와 쿼리를 나눈다.
12. 백앤드가 너무 복잡해져서 클라이언트가 각각 서비스에 통신하기 어려움. 그래서 API GATEWAY가 나옴.
13. 아키택쳐가 복잡해지다보니 MS하나가 다운이되면 연쇄적으로 다른 MS들도 다운될 가능성이생김.
14. 연쇄적으로 이런 다운이 전파되지않도록 차단하기위해 나온것이 *서킷 브레이커 패턴*임.
15. 너무 많은 MS와 DB, 관리하는 MS등 너무 복잡하여 그것을 도와주려고 나온것이 *오케스트레이션*인데, *kubernetes* 같은것이 있음.
