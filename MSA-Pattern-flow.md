# MSA (MicroService Architecture)

1. 시작은 Monolithic 아키텍쳐 - 기본 하나의 서버 하나의 DB에.
- 배포시 전체를 다 스케일링 해줘야해서 개발사이클이 늦어짐.
2. MSA의 시작 - 서버를 도메인 기준으로 분리하여 배포 단위를 나눔. 
- 서버가 모두 같은 DB를 바라보면서 Synchronous(동기화)문제가 생김.
4. 각 서비스별로 독립적인 DB를 둠. - 현재 가장 많이쓰는 형태.
- 서비스별로 통신을 더욱 자주, 많이 하게됨. HTTP로 통신하기에는 난이도가 높아짐.
5. 더 로우레벨에서 통신할수있는 gRPC(Remote Procedure Call)같은 걸 사용하게됨. 속도의강점.
- 서비스에서 워터폴 이펙트가 생김. Synchronous(동기화) 문제.<br>ex a().b().c() 에서 a가 끝나지않으면 결국 b,c전부 대기중
6. Asynchronous(비동기) 방식으로 하기위해 이벤트드리븐 아키텍쳐가 생김.
- 이벤트드리븐 아키텍쳐란?
-- 요청을 EventBroker에 이벤트에 등록하고 끝냄.
-- 특정이벤트를 구독하고있는 다른 서비스가 이벤트를 가져가서 처리함.

    <br><br>
- Process가 필요한 서비스들이 있음. 여러 마이크로서비스서버에 거쳐서 다중작업을 하게되는데, 그중에 에러가 나면 분산된 DB 때문에 롤백이 어려움.
    ex) 상품결제 - 상품(재고감소),payment(결제),user(포인트지급),notification(알림)
    
7. Saga Pattern이 나옴.
- 여러 서비스의 트랜잭션을 묶어주고, 문제가 나면 보상트랜젝션을 통해 롤백을 함.
- 중개서버가 하나 필요함. 떄문에 이벤트드리븐 아키텍쳐와 같이 쓰면좋음.
    <br>
- 기존 Monologo(1) 에서는 CRUD 로 개발을 하엿는데, MSA에서는 각 MS의 주목적이나 특징이 생김.
8. 그 특징을 기준으로 MS를 command와 Query부분을 분리함. 그러면서 각각 MS별로 생성이나 조회에 최적화 DB를 사용하게됨.
- 효율을 높임.<br>
- 독립적인 스케일링이 가능해져서 인프라 최적화도 더욱 타이트해짐.<br>
    *이것이 CQRS(Command Query Responsibiliy Segregration) 패턴*
    커맨드와 쿼리를 나눈다.
  <br>
- 백앤드가 너무 복잡해져서 클라이언트가 각각 서비스에 통신하기 어려움.
9. API GATEWAY가 생김.
  - gateway를 통하면서 알맞는 MS로 요청을 알아서 처리해줌.
  - 점점 아키택쳐가 복잡해지다보니 MS하나가 다운이되면 연쇄적으로 다른 MS들도 다운될 가능성이생김.
10. 서킷 브레이커 패턴 나옴.
  - 연쇄적으로 이런 다운이 전파되지않도록 차단해줌.
  - 너무 많은 MS와 DB, 관리하는 MS등, 너무 복잡함.
11. 오케스트레이션 패턴이 나옴.
- MS 들을 전체적으로 다 관리해줌.
- *kubernetes* 같은것이 있음.
<br>
<br>
<br>
[원본영상 - 코드팩토리 MAS요소 6가지 7분컷](https://www.youtube.com/watch?v=e8iAR3VWffM)

